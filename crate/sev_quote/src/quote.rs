use crate::{
    REPORT_SIZE,
    error::Error,
    kds_client::{
        SevProdName, fetch_amd_vcek_cert_chain, fetch_amd_vlek_cert_chain, fetch_revocation_list,
        fetch_vcek,
    },
    policy::SevQuoteVerificationPolicy,
    verify::{
        bytes_to_chain, verify_chain_certificates, verify_quote_policy, verify_revocation_list,
        verify_tcb,
    },
};

use serde::{Deserialize, Serialize};
use sev::{
    certs::snp::ca,
    certs::snp::{Certificate, Chain, Verifiable},
    firmware::{
        guest::{AttestationReport, Firmware},
        host::{CertTableEntry, CertType},
    },
    parser::{ByteParser, Decoder, Encoder},
};

use x509_parser::{self, pem::parse_x509_pem};

#[cfg(target_os = "linux")]
use crate::REPORT_DATA_SIZE;

const SEV_PROD_NAME: SevProdName = SevProdName::Milan;
const KDS_CERT_SITE: &str = "https://kdsintf.amd.com";

#[repr(C)]
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Quote {
    pub report: AttestationReport,
    pub certs: Vec<CertTableEntry>,
}

impl From<(AttestationReport, Vec<CertTableEntry>)> for Quote {
    fn from(attr: (AttestationReport, Vec<CertTableEntry>)) -> Self {
        Quote {
            report: attr.0,
            certs: attr.1,
        }
    }
}

impl TryFrom<&[u8]> for Quote {
    type Error = crate::error::Error;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        if bytes.len() < REPORT_SIZE {
            return Err(Self::Error::QuoteError);
        }

        let report = AttestationReport::from_bytes(&bytes[..REPORT_SIZE])?;

        // No certificates
        if bytes.len() < REPORT_SIZE + 4 {
            return Ok((report, vec![]).into());
        }

        let num_certs = u32::from_le_bytes([
            bytes[REPORT_SIZE],
            bytes[REPORT_SIZE + 1],
            bytes[REPORT_SIZE + 2],
            bytes[REPORT_SIZE + 3],
        ]);

        let mut certs = vec![];

        let mut offset = REPORT_SIZE + 4;

        for _ in 0..num_certs {
            if offset >= bytes.len() {
                return Err(Self::Error::QuoteCertError);
            }

            let cert_table_entry_len = u32::from_le_bytes([
                bytes[offset],
                bytes[offset + 1],
                bytes[offset + 2],
                bytes[offset + 3],
            ]);

            offset += 4;

            let mut reader = &bytes[offset..offset + cert_table_entry_len as usize];
            let cert = CertTableEntry::decode(&mut reader, ())?;
            certs.push(cert);

            offset += cert_table_entry_len as usize;
        }

        Ok((report, certs).into())
    }
}

impl TryFrom<Vec<u8>> for Quote {
    type Error = crate::error::Error;

    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {
        Quote::try_from(&bytes[..])
    }
}

impl TryFrom<Quote> for Vec<u8> {
    type Error = crate::error::Error;

    fn try_from(quote: Quote) -> Result<Self, Self::Error> {
        let mut raw_quote = quote.report.to_bytes()?.to_vec();

        let num_certs = (quote.certs.len() as u32).to_le_bytes();
        num_certs.encode(&mut raw_quote, ())?;

        for cert in quote.certs {
            let mut buf = vec![];
            cert.encode(&mut buf, ())?;
            let buf_len = (buf.len() as u32).to_le_bytes();
            buf_len.encode(&mut raw_quote, ())?;
            buf.encode(&mut raw_quote, ())?;
        }

        Ok(raw_quote)
    }
}

/// Parse the raw quote into an `AttestationReport`
pub fn parse_quote(raw_quote: &[u8]) -> Result<Quote, Error> {
    Quote::try_from(raw_quote)
}

/// Get the quote of the SEV VM
///
/// Source: <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
#[cfg(target_os = "linux")]
pub fn get_quote(user_report_data: &[u8; REPORT_DATA_SIZE]) -> Result<Vec<u8>, Error> {
    // Open a connection to the firmware.
    let mut fw = Firmware::open()?;

    // Request a standard attestation report.
    let (report, certs) = fw.get_ext_report(None, Some(*user_report_data), None)?;
    let report = AttestationReport::from_bytes(&report)?;

    let quote = Quote {
        report,
        certs: certs.unwrap_or(vec![]),
    };

    quote.try_into()
}

/// The verification of the quote includes:
/// - Check the quote has been signed by the VLEK/VCEK cert
/// - Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
/// - Check the TCB information
///
/// Note:
/// - VLEK = Versioned Loaded Endorsement Key
/// - VCEK = Versioned Chip Endorsement Key
///
/// Reference:
/// - <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/57230.pdf>
/// - <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
pub fn verify_quote(quote: &Quote, policy: &SevQuoteVerificationPolicy) -> Result<(), Error> {
    // Check the policy
    verify_quote_policy(&quote.report, policy)?;

    // let chain = Chain::from_cert_table_der(quote.certs.clone())?;

    // Try to build the Chain object by dealing with various cases.
    let vlek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::VLEK);
    let ark = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ARK);
    let ask = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ASK);
    let vcek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::VCEK);

    let chain = match (vlek, ark, ask, vcek) {
        (Some(vlek), _, _, _) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vlek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vek: Certificate::from_der(&vlek.data)?,
        }),
        (None, Some(ark), Some(ask), Some(vcek)) => Ok(Chain {
            ca: ca::Chain::from_der(&ark.data, &ask.data)?,
            vek: Certificate::from_der(&vcek.data)?,
        }),
        (None, None, None, None) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vcek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vek: Certificate::from_der(&fetch_vcek(
                KDS_CERT_SITE,
                SEV_PROD_NAME,
                &quote.report.chip_id,
                quote.report.reported_tcb,
            )?)?,
        }),
        (_, _, _, _) => Err(Error::Unimplemented(
            "Unhandled combination of ARK/ASK/VCEK/VLEK certificates".to_owned(),
        )),
    }?;

    // Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
    verify_chain_certificates(&chain)?;

    // Check the quote has been signed by the VLEK/VCEK
    (&chain, &quote.report).verify()?;

    // Check the revocation list
    let crl = fetch_revocation_list(KDS_CERT_SITE, SEV_PROD_NAME)?;
    verify_revocation_list(&chain, &crl)?;

    let vcek_pem = chain.vek.to_pem()?;
    let (rem, pem) = parse_x509_pem(&vcek_pem)?;

    if !rem.is_empty() || &pem.label != "CERTIFICATE" {
        return Err(Error::InvalidFormat(
            "Not a certificate or certificate is malformed".to_owned(),
        ));
    }

    let vcek = pem
        .parse_x509()
        .map_err(|e| Error::X509ParserError(e.into()))?;

    // Check the TCB fields
    verify_tcb(&quote.report, &vcek)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::is_sev;

    use super::*;
    use env_logger::Target;

    fn init() {
        let mut builder = env_logger::builder();
        let builder = builder.is_test(true);
        let builder = builder.target(Target::Stdout);
        let _ = builder.try_init();
    }

    #[test]
    fn test_sev_get_quote() {
        if is_sev() {
            assert!(
                get_quote(b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000")
                    .is_ok()
            );
        } else {
            println!("[WARNING] No SEV found, skipped `test_sev_get_quote` test");
        }
    }

    // #[test]
    // fn test_sev_verify_quote1() {
    //     init();

    //     let raw_report = include_bytes!("../data/report-vlek-aws.bin");
    //     let quote = parse_quote(raw_report).unwrap();

    //     verify_quote(
    //         &quote,
    //         &SevQuoteVerificationPolicy {
    //             measurement: Some(hex::decode("ac3e4d8516634a5e0180338175cc827c90061414bd699b5af30712caa291fa34ed06cc622792bc1177126bd115a826ba").unwrap().try_into().unwrap()),
    //             report_data: Some(hex::decode("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap().try_into().unwrap()) ,
    //             ..Default::default()
    //         }
    //     )
    //     .unwrap();
    // }

    #[test]
    fn test_sev_verify_quote2() {
        init();

        let raw_report = include_bytes!("../data/report-ark-ask-vcek.bin");

        let quote = parse_quote(raw_report).unwrap();
        let report_data = [0u8; 64];
        let measurement: [u8; 48] = hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d").unwrap().try_into().unwrap();

        verify_quote(
            &quote,
            &SevQuoteVerificationPolicy {
                measurement: Some(measurement),
                report_data: Some(report_data),
                ..Default::default()
            },
        )
        .unwrap();
    }

    // #[test]
    // fn test_sev_verify_quote3() {
    //     init();

    //     let raw_report = include_bytes!("../data/report-no-cert.bin");

    //     let quote = parse_quote(raw_report).unwrap();

    //     verify_quote(
    //         &quote,
    //         &SevQuoteVerificationPolicy {
    //             measurement: Some(hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d").unwrap().try_into().unwrap()),
    //             report_data: Some(*b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000") ,
    //             ..Default::default()
    //         }
    //     )
    //     .unwrap();
    // }
}
