use crate::{
    error::Error,
    kds_client::{
        fetch_amd_vcek_cert_chain, fetch_amd_vlek_cert_chain, fetch_revocation_list, fetch_vcek,
        SevProdName,
    },
    policy::SevQuoteVerificationPolicy,
    verify::{
        bytes_to_chain, verify_chain_certificates, verify_quote_policy, verify_revocation_list,
        verify_tcb,
    },
};

use serde::{Deserialize, Serialize};
use sev::{
    certs::snp::Verifiable,
    firmware::{guest::*, host::CertTableEntry},
};

use sev::{
    certs::snp::{ca, Certificate, Chain},
    firmware::host::CertType,
};

use uuid::Uuid;
use x509_parser::{self, pem::parse_x509_pem};

#[cfg(target_os = "linux")]
use crate::REPORT_DATA_SIZE;

const AWS_VLEK_TYPE: Uuid = Uuid::from_fields(
    0xa8074bc2,
    0xa25a,
    0x483e,
    &[0xaa, 0xe6, 0x39, 0xc0, 0x45, 0xa0, 0xb8, 0xa1],
);

const SEV_PROD_NAME: SevProdName = SevProdName::Milan;
const KDS_CERT_SITE: &str = "https://kdsintf.amd.com";

#[repr(C)]
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Quote {
    pub report: AttestationReport,
    pub certs: Vec<CertTableEntry>,
}

impl From<(AttestationReport, Vec<CertTableEntry>)> for Quote {
    fn from(attr: (AttestationReport, Vec<CertTableEntry>)) -> Self {
        Quote {
            report: attr.0,
            certs: attr.1,
        }
    }
}

/// Parse the raw quote into an AttestationReport
pub fn parse_quote(raw_quote: &[u8]) -> Result<Quote, Error> {
    bincode::deserialize(raw_quote)
        .map_err(|_| Error::InvalidFormat("Can't deserialize the SEV report bytes".to_owned()))
}

/// Get the quote of the SEV VM
///
/// Source: <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
#[cfg(target_os = "linux")]
pub fn get_quote(user_report_data: &[u8; REPORT_DATA_SIZE]) -> Result<Vec<u8>, Error> {
    // Open a connection to the firmware.
    let mut fw = Firmware::open()?;

    // Request a standard attestation report.
    let (report, certs) = fw.get_ext_report(None, Some(*user_report_data), None)?;

    let quote = Quote {
        report,
        certs: certs.unwrap_or(vec![]),
    };

    bincode::serialize(&quote)
        .map_err(|_| Error::InvalidFormat("Can't serialize the SEV quote".to_owned()))
}

/// The verification of the quote includes:
/// - Check the quote has been signed by the VLEK/VCEK cert
/// - Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
/// - Check the TCB information
///
/// Note:
/// - VLEK = Versioned Loaded Endorsement Key
/// - VCEK = Versioned Chip Endorsement Key
///
/// Reference:
/// - <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/57230.pdf>
/// - <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
pub fn verify_quote(quote: &Quote, policy: &SevQuoteVerificationPolicy) -> Result<(), Error> {
    // Check the policy
    verify_quote_policy(&quote.report, policy)?;

    // Try to build the Chain object by dealing with various cases.
    let vlek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::OTHER(AWS_VLEK_TYPE));
    let ark = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ARK);
    let ask = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ASK);
    let vcek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::VCEK);

    let chain = match (vlek, ark, ask, vcek) {
        (Some(vlek), _, _, _) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vlek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vcek: Certificate::from_der(&vlek.data)?,
        }),
        (None, Some(ark), Some(ask), Some(vcek)) => Ok(Chain {
            ca: ca::Chain::from_der(&ark.data, &ask.data)?,
            vcek: Certificate::from_der(&vcek.data)?,
        }),
        (None, None, None, None) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vcek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vcek: Certificate::from_der(&fetch_vcek(
                KDS_CERT_SITE,
                SEV_PROD_NAME,
                &quote.report.chip_id,
                quote.report.reported_tcb,
            )?)?,
        }),
        (_, _, _, _) => Err(Error::Unimplemented(
            "Unhandled combination of ARK/ASK/VCEK/VLEK certificates".to_owned(),
        )),
    }?;

    // Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
    verify_chain_certificates(&chain)?;

    // Check the quote has been signed by the VLEK/VCEK
    (&chain, &quote.report).verify()?;

    // Check the revocation list
    let crl = fetch_revocation_list(KDS_CERT_SITE, SEV_PROD_NAME)?;
    verify_revocation_list(&chain, &crl)?;

    let vcek_pem = chain.vcek.to_pem()?;
    let (rem, pem) = parse_x509_pem(&vcek_pem)?;

    if !rem.is_empty() || &pem.label != "CERTIFICATE" {
        return Err(Error::InvalidFormat(
            "Not a certificate or certificate is malformed".to_owned(),
        ));
    }

    let vcek = pem
        .parse_x509()
        .map_err(|e| Error::X509ParserError(e.into()))?;

    // Check the TCB fields
    verify_tcb(&quote.report, &vcek)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::is_sev;

    use super::*;
    use env_logger::Target;

    fn init() {
        let mut builder = env_logger::builder();
        let builder = builder.is_test(true);
        let builder = builder.target(Target::Stdout);
        let _ = builder.try_init();
    }

    #[test]
    fn test_sev_get_quote() {
        if is_sev() {
            assert!(
                get_quote(b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000")
                    .is_ok()
            );
        } else {
            println!("[WARNING] No SEV found, skipped `test_sev_get_quote` test");
        }
    }

    #[test]
    fn test_sev_verify_quote1() {
        init();
        let raw_report = include_bytes!("../data/report-vlek.bin");

        let quote = parse_quote(raw_report).unwrap();

        assert!(verify_quote(
            &quote,
            &SevQuoteVerificationPolicy {
                measurement: Some(hex::decode("c2c84b9364fc9f0f54b04534768c860c6e0e386ad98b96e8b98eca46ac8971d05c531ba48373f054c880cfd1f4a0a84e").unwrap().try_into().unwrap()),
                report_data: Some(hex::decode("0d155251f139f682dc4ea2798feceed7c475461c8faecf7496401500956624540000000000000000000000000000000000000000000000000000000000000000").unwrap().try_into().unwrap()) ,
                ..Default::default()
            }
        )
        .is_ok());
    }

    #[test]
    fn test_sev_verify_quote2() {
        init();
        let raw_report = include_bytes!("../data/report-ark-ask-vcek.bin");

        let quote = parse_quote(raw_report).unwrap();

        assert!(verify_quote(
            &quote,
            &SevQuoteVerificationPolicy {
                measurement: Some(hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d").unwrap().try_into().unwrap()),
                report_data: Some(*b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000") ,
                ..Default::default()
            }
        )
        .is_ok());
    }

    #[test]
    fn test_sev_verify_quote3() {
        init();

        let raw_report = include_bytes!("../data/report-no-cert.bin");

        let quote = parse_quote(raw_report).unwrap();

        assert!(verify_quote(
            &quote,
            &SevQuoteVerificationPolicy {
                measurement: Some(hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d").unwrap().try_into().unwrap()),
                report_data: Some(*b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000") ,
                ..Default::default()
            }
        )
        .is_ok());
    }
}
