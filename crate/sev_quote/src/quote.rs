use crate::{
    error::Error,
    kds_client::{
        fetch_amd_vcek_cert_chain, fetch_amd_vlek_cert_chain, fetch_revocation_list, fetch_vcek,
        SevProdName,
    },
    policy::SevQuoteVerificationPolicy,
    verify::{
        bytes_to_chain, verify_chain_certificates, verify_quote_policy, verify_revocation_list,
        verify_tcb,
    },
};

use sev::{
    certs::snp::Verifiable,
    firmware::{
        guest::{AttestationReport, Firmware},
        host::CertTableEntry,
    },
    parser::{ByteParser, Decoder, Encoder},
};

use sev::{
    certs::snp::{ca, Certificate, Chain},
    firmware::host::CertType,
};

use x509_parser::{self, pem::parse_x509_pem};

#[cfg(target_os = "linux")]
use crate::REPORT_DATA_SIZE;

const SEV_PROD_NAME: SevProdName = SevProdName::Milan;
const KDS_CERT_SITE: &str = "https://kdsintf.amd.com";

#[repr(C)]
#[derive(Debug, Clone)]
pub struct Quote {
    pub report: AttestationReport,
    pub certs: Vec<CertTableEntry>,
}

impl From<(AttestationReport, Vec<CertTableEntry>)> for Quote {
    fn from(attr: (AttestationReport, Vec<CertTableEntry>)) -> Self {
        Quote {
            report: attr.0,
            certs: attr.1,
        }
    }
}

/// Parse the raw quote into an `AttestationReport`
pub fn parse_quote(raw_quote: &[u8]) -> Result<Quote, Error> {
    // Try to parse as just an AttestationReport first (simple format)
    if let Ok(report) = AttestationReport::from_bytes(raw_quote) {
        return Ok(Quote {
            report,
            certs: vec![],
        });
    }

    const REPORT_SIZE: usize = 1184; // Size of SNP AttestationReport
    if raw_quote.len() < REPORT_SIZE {
        return Err(Error::InvalidFormat("Quote too small".to_owned()));
    }

    // Always parse the fixed-size report prefix. Some carriers (e.g., RATLS certificates)
    // may append extra data after the AttestationReport.
    let report = AttestationReport::from_bytes(&raw_quote[..REPORT_SIZE]).map_err(|e| {
        Error::InvalidFormat(format!("Can't deserialize the SEV report bytes: {}", e))
    })?;

    // Try to parse as AttestationReport + cert table entries
    // Format: [report_bytes:1184][num_certs:4][cert1][cert2]...
    if raw_quote.len() < REPORT_SIZE + 4 {
        return Ok(Quote {
            report,
            certs: vec![],
        });
    }

    // Parse number of certs
    let num_certs = u32::from_le_bytes([
        raw_quote[REPORT_SIZE],
        raw_quote[REPORT_SIZE + 1],
        raw_quote[REPORT_SIZE + 2],
        raw_quote[REPORT_SIZE + 3],
    ]);

    // Guard against non-cert-table payloads (e.g., appended DER cert chain) being
    // misinterpreted as a huge certificate count.
    if num_certs > 16 {
        return Ok(Quote {
            report,
            certs: vec![],
        });
    }

    let mut certs = Vec::new();
    let mut offset = REPORT_SIZE + 4;

    for _ in 0..num_certs {
        if offset >= raw_quote.len() {
            // Not a valid cert table; treat as appended data.
            return Ok(Quote {
                report,
                certs: vec![],
            });
        }

        let mut reader: &[u8] = &raw_quote[offset..];
        let cert = match CertTableEntry::decode(&mut reader, ()) {
            Ok(cert) => cert,
            Err(_) => {
                // Not a valid cert table; treat as appended data.
                return Ok(Quote {
                    report,
                    certs: vec![],
                });
            }
        };
        let bytes_read = raw_quote[offset..].len() - reader.len();
        offset += bytes_read;
        certs.push(cert);
    }

    Ok(Quote { report, certs })
}

/// Get the quote of the SEV VM
///
/// Source: <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
#[cfg(target_os = "linux")]
pub fn get_quote(user_report_data: &[u8; REPORT_DATA_SIZE]) -> Result<Vec<u8>, Error> {
    // Open a connection to the firmware.
    let mut fw = Firmware::open()?;

    // Request a standard attestation report.
    let (report, certs) = fw.get_ext_report(None, Some(*user_report_data), None)?;

    // Serialize: [report_bytes][num_certs:4][cert1][cert2]...
    let mut result = report
        .to_bytes()
        .map_err(|e| Error::InvalidFormat(format!("Can't serialize the SEV report: {}", e)))?;

    let certs = certs.unwrap_or(vec![]);
    result.extend_from_slice(&(certs.len() as u32).to_le_bytes());

    for cert in &certs {
        cert.encode(&mut result, ())
            .map_err(|e| Error::InvalidFormat(format!("Can't serialize cert: {}", e)))?;
    }

    Ok(result)
}

/// The verification of the quote includes:
/// - Check the quote has been signed by the VLEK/VCEK cert
/// - Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
/// - Check the TCB information
///
/// Note:
/// - VLEK = Versioned Loaded Endorsement Key
/// - VCEK = Versioned Chip Endorsement Key
///
/// Reference:
/// - <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/57230.pdf>
/// - <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
pub fn verify_quote(quote: &Quote, policy: &SevQuoteVerificationPolicy) -> Result<(), Error> {
    // Check the policy
    verify_quote_policy(&quote.report, policy)?;

    // Try to build the Chain object by dealing with various cases.
    let vlek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::VLEK);
    let ark = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ARK);
    let ask = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::ASK);
    let vcek = quote
        .certs
        .iter()
        .find(|item| item.cert_type == CertType::VCEK);

    let chain = match (vlek, ark, ask, vcek) {
        (Some(vlek), _, _, _) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vlek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vek: Certificate::from_der(&vlek.data)?,
        }),
        (None, Some(ark), Some(ask), Some(vcek)) => Ok(Chain {
            ca: ca::Chain::from_der(&ark.data, &ask.data)?,
            vek: Certificate::from_der(&vcek.data)?,
        }),
        (None, None, None, None) => Ok(Chain {
            ca: bytes_to_chain(&fetch_amd_vcek_cert_chain(KDS_CERT_SITE, SEV_PROD_NAME)?)?,
            vek: Certificate::from_der(&fetch_vcek(
                KDS_CERT_SITE,
                SEV_PROD_NAME,
                &quote.report.chip_id,
                quote.report.reported_tcb,
            )?)?,
        }),
        (_, _, _, _) => Err(Error::Unimplemented(
            "Unhandled combination of ARK/ASK/VCEK/VLEK certificates".to_owned(),
        )),
    }?;

    // Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
    verify_chain_certificates(&chain)?;

    // Check the quote has been signed by the VLEK/VCEK
    (&chain, &quote.report).verify()?;

    // Check the revocation list
    let crl = fetch_revocation_list(KDS_CERT_SITE, SEV_PROD_NAME)?;
    verify_revocation_list(&chain, &crl)?;

    let vcek_pem = chain.vek.to_pem()?;
    let (rem, pem) = parse_x509_pem(&vcek_pem)?;

    if !rem.is_empty() || &pem.label != "CERTIFICATE" {
        return Err(Error::InvalidFormat(
            "Not a certificate or certificate is malformed".to_owned(),
        ));
    }

    let vcek = pem
        .parse_x509()
        .map_err(|e| Error::X509ParserError(e.into()))?;

    // Check the TCB fields
    verify_tcb(&quote.report, &vcek)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::is_sev;

    use super::*;
    use env_logger::Target;

    fn init() {
        let mut builder = env_logger::builder();
        let builder = builder.is_test(true);
        let builder = builder.target(Target::Stdout);
        let _ = builder.try_init();
    }

    #[test]
    fn test_sev_get_quote() {
        if is_sev() {
            assert!(
                get_quote(b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000")
                    .is_ok()
            );
        } else {
            println!("[WARNING] No SEV found, skipped `test_sev_get_quote` test");
        }
    }

    #[test]
    fn test_sev_verify_quote1() {
        init();

        // Policy-only check (offline). Full quote verification may require online collateral.
        let raw_report = include_bytes!("../data/report-vlek-aws.bin");
        let quote = parse_quote(raw_report).unwrap();

        let policy = SevQuoteVerificationPolicy {
            measurement: Some(
                hex::decode("ac3e4d8516634a5e0180338175cc827c90061414bd699b5af30712caa291fa34ed06cc622792bc1177126bd115a826ba")
                    .unwrap()
                    .try_into()
                    .unwrap(),
            ),
            report_data: Some(
                hex::decode("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
                    .unwrap()
                    .try_into()
                    .unwrap(),
            ),
            ..Default::default()
        };

        crate::verify::verify_quote_policy(&quote.report, &policy).unwrap();
    }

    #[test]
    fn test_sev_verify_quote2() {
        init();

        let raw_report = include_bytes!("../data/report-ark-ask-vcek.bin");
        let quote = parse_quote(raw_report).unwrap();

        let policy = SevQuoteVerificationPolicy {
            measurement: Some(
                hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d")
                    .unwrap()
                    .try_into()
                    .unwrap(),
            ),
            report_data: Some(*b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000"),
            ..Default::default()
        };

        crate::verify::verify_quote_policy(&quote.report, &policy).unwrap();
    }

    #[test]
    fn test_sev_verify_quote3() {
        init();

        let raw_report = include_bytes!("../data/report-no-cert.bin");

        let quote = parse_quote(raw_report).unwrap();

        assert!(quote.certs.is_empty());

        // Policy-only check (offline). Full verification requires online collateral fetching.
        let policy = SevQuoteVerificationPolicy {
            measurement: Some(
                hex::decode("41a95b6fbe794f1d3bb919934adc5e44583b57e4a5c3f489ffe775ecb8e23d3947001e886277751ba06ae793c2c8904d")
                    .unwrap()
                    .try_into()
                    .unwrap(),
            ),
            report_data: Some(*b"0123456789abcdef012345678789abcdef0123456789abcdef00000000000000"),
            ..Default::default()
        };
        crate::verify::verify_quote_policy(&quote.report, &policy).unwrap();
    }
}
