use std::collections::HashMap;

use crate::{
    error::Error,
    snp_extension::{check_cert_ext_byte, check_cert_ext_bytes, SnpOid},
};

use asn1_rs::Oid;

use log::debug;
use openssl::{
    ec::EcKey,
    ecdsa::EcdsaSig,
    pkey::Public,
    sha::Sha384,
    x509::{CrlStatus, X509Crl, X509},
};
use reqwest::get;
use serde::{Deserialize, Serialize};
use sev::{
    certs::snp::Verifiable,
    firmware::{
        guest::*,
        host::{CertTableEntry, TcbVersion},
    },
};

use sev::{
    certs::snp::{ca, Certificate, Chain},
    firmware::host::CertType,
};

use uuid::Uuid;
use x509_parser::{
    self, certificate::X509Certificate, pem::parse_x509_pem, prelude::X509Extension,
};

const AWS_VLEK_TYPE: Uuid = Uuid::from_fields(
    0xa8074bc2,
    0xa25a,
    0x483e,
    &[0xaa, 0xe6, 0x39, 0xc0, 0x45, 0xa0, 0xb8, 0xa1],
);

const KDS_CERT_SITE: &str = "https://kdsintf.amd.com";
const KDS_VCEK: &str = "/vcek/v1";
const KDS_VLEK: &str = "/vlek/v1";
const KDS_CERT_CHAIN: &str = "cert_chain";
const KDS_CRL: &str = "crl";
const SEV_PROD_NAME: &str = "Milan";
const SEV_REPORT_DATA_SIZE: usize = 64;

#[repr(C)]
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SEVQuote {
    pub report: AttestationReport,
    pub certs: Vec<CertTableEntry>,
}

impl From<(AttestationReport, Vec<CertTableEntry>)> for SEVQuote {
    fn from(attr: (AttestationReport, Vec<CertTableEntry>)) -> Self {
        SEVQuote {
            report: attr.0,
            certs: attr.1,
        }
    }
}

/// Get the quote of the SEV VM
///
/// Source: <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
pub fn get_quote(user_report_data: &[u8]) -> Result<SEVQuote, Error> {
    // Open a connection to the firmware.
    let mut fw = Firmware::open()?;

    if user_report_data.len() > SEV_REPORT_DATA_SIZE {
        return Err(Error::InvalidFormat(format!(
            "The user report data file should contain at most 64 bytes (read: {}B)",
            user_report_data.len()
        )));
    }

    let user_report_data = {
        let padding = vec![0; SEV_REPORT_DATA_SIZE - user_report_data.len()];
        [user_report_data, &padding].concat()
    };

    // Request a standard attestation report.
    Ok(SEVQuote::from(
        fw.get_ext_report(
            None,
            Some(
                user_report_data
                    .try_into()
                    .map_err(|_| Error::InvalidFormat("Report data malformed".to_owned()))?,
            ),
            None,
        )?,
    ))
}

/// The verification of the quote includes:
/// - Check the quote has been signed by the VLEK/VCEK cert
/// - Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
/// - Check the TCB information
///
/// Note:
/// - VLEK = Versioned Loaded Endorsement Key
/// - VCEK = Versioned Chip Endorsement Key
///
/// Reference:
/// - <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/57230.pdf>
/// - <https://www.amd.com/content/dam/amd/en/documents/developer/58217-epyc-9004-ug-platform-attestation-using-virtee-snp.pdf>
pub async fn verify_quote(
    quote: &AttestationReport,
    certificates: &[CertTableEntry],
    measurement: Option<[u8; 48]>,
) -> Result<(), Error> {
    // Try to build the Chain object by dealing with various cases.
    let vlek = certificates
        .iter()
        .find(|item| item.cert_type == CertType::OTHER(AWS_VLEK_TYPE));
    let ark = certificates
        .iter()
        .find(|item| item.cert_type == CertType::ARK);
    let ask = certificates
        .iter()
        .find(|item| item.cert_type == CertType::ASK);
    let vcek = certificates
        .iter()
        .find(|item| item.cert_type == CertType::VCEK);

    let chain = match (vlek, ark, ask, vcek) {
        (Some(vlek), _, _, _) => Ok(Chain {
            ca: request_amd_vlek_cert_chain(SEV_PROD_NAME).await?,
            vcek: Certificate::from_der(&vlek.data)?,
        }),
        (None, Some(ark), Some(ask), Some(vcek)) => Ok(Chain {
            ca: ca::Chain::from_pem(&ark.data, &ask.data)?,
            vcek: Certificate::from_der(&vcek.data)?,
        }),
        (None, None, None, None) => Ok(Chain {
            ca: request_amd_vcek_cert_chain(SEV_PROD_NAME).await?,
            vcek: request_vcek(SEV_PROD_NAME, quote.chip_id, quote.reported_tcb).await?,
        }),
        (_, _, _, _) => Err(Error::Unimplemented(
            "Unhandled combination of ARK/ASK/VCEK/VLEK certificates".to_owned(),
        )),
    }?;

    // Check that the VLEK/VCEK has been generated by AMD (verify the certificate chain)
    verify_chain_certificates(&chain)?;

    // Check the quote has been signed by the VLEK/VCEK
    verify_quote_signature(quote, &chain.vcek)?;

    // Check the revocation list
    verify_revocation_list(&chain).await?;

    let vcek_pem = chain.vcek.to_pem()?;
    let (rem, pem) = parse_x509_pem(&vcek_pem)?;

    if !rem.is_empty() || &pem.label != "CERTIFICATE" {
        return Err(Error::InvalidFormat(
            "Not a certificate or certificate is malformed".to_owned(),
        ));
    }

    let vcek = pem
        .parse_x509()
        .map_err(|e| Error::X509ParserError(e.into()))?;

    // Check the TCB fields
    verify_tcb(quote, &vcek)?;

    // Check the measurement
    if let Some(measurement) = measurement {
        if quote.measurement != measurement {
            return Err(Error::VerificationFailure(
                "Measurement miss-matches expected value".to_owned(),
            ));
        }
    }

    Ok(())
}

/// Verify the certification chain against the AMD revocation list
async fn verify_revocation_list(chain: &Chain) -> Result<(), Error> {
    // Get the crl
    let crl = request_crl(SEV_PROD_NAME).await?;

    // Verify that the crl has been signed by ARK
    crl.verify(chain.ca.ark.public_key()?.as_ref())?;

    // Verify ASK is not revoked
    match crl.get_by_cert(&chain.ca.ask.clone().into()) {
        CrlStatus::Revoked(_author_key_en) => {
            return Err(Error::VerificationFailure(
                "The ASK certificate has been revoked".to_owned(),
            ))
        }
        _ => debug!("ASK is not revoked!"),
    }

    // Verify VCEK is not revoked
    match crl.get_by_cert(&chain.vcek.clone().into()) {
        CrlStatus::Revoked(_author_key_en) => {
            return Err(Error::VerificationFailure(
                "The VCEK certificate has been revoked".to_owned(),
            ))
        }
        _ => debug!("VCEK is not revoked!"),
    }

    Ok(())
}
/// Validate that the VLEK or VCEK certificate is signed by the AMD root of trust certificates
fn verify_chain_certificates(cert_chain: &Chain) -> Result<(), Error> {
    let ark = &cert_chain.ca.ark;
    let ask = &cert_chain.ca.ask;
    let vcek = &cert_chain.vcek;

    if (ark, ark).verify().is_err() {
        return Err(Error::VerificationFailure(
            "The AMD ARK is not self-signed!".to_owned(),
        ));
    }

    debug!("The AMD ARK was self-signed...");

    if (ark, ask).verify().is_err() {
        return Err(Error::VerificationFailure(
            "The AMD ASK was not signed by the AMD ARK!".to_owned(),
        ));
    }

    debug!("The AMD ASK was signed by the AMD ARK...");

    if (ask, vcek).verify().is_err() {
        return Err(Error::VerificationFailure(
            "The VCEK was not signed by the AMD ASK!".to_owned(),
        ));
    }

    debug!("The VCEK was signed by the AMD ASK...");

    Ok(())
}

/// Validate that the quote has been signed by the VCEK certificate
fn verify_quote_signature(quote: &AttestationReport, vcek: &Certificate) -> Result<(), Error> {
    let ar_signature: EcdsaSig = EcdsaSig::try_from(&quote.signature)?;
    let signed_bytes: &[u8] =
        &bincode::serialize(&quote).map_err(|_| Error::QuoteMalformed)?[0x0..0x2A0];
    let amd_vcek_pubkey: EcKey<Public> = vcek.public_key()?.ec_key()?;
    let mut hasher: Sha384 = Sha384::new();
    hasher.update(signed_bytes);
    let base_message_digest: [u8; 48] = hasher.finish();

    if ar_signature.verify(&base_message_digest, &amd_vcek_pubkey)? {
        debug!("VCEK signed the Attestation Report!");
    } else {
        return Err(Error::VerificationFailure(
            "VCEK did NOT sign the Attestation Report!".to_owned(),
        ));
    }

    Ok(())
}

/// Validate the guest Trusted Compute Base by verifying the following fields in an attestation report and a VCEK:
/// - Bootloader
/// - TEE
/// - SNP
/// - Microcode
/// - Chip ID
fn verify_tcb(report: &AttestationReport, cert: &X509Certificate) -> Result<(), Error> {
    let extensions: HashMap<Oid, &X509Extension> = cert.extensions_map()?;
    if let Some(cert_bl) = extensions.get(&SnpOid::BootLoader.oid()) {
        if !check_cert_ext_byte(cert_bl, report.reported_tcb.bootloader)? {
            return Err(Error::VerificationFailure(
                "Report TCB Boot Loader and Certificate Boot Loader mismatch
    encountered."
                    .to_owned(),
            ));
        }
    }

    if let Some(cert_tee) = extensions.get(&SnpOid::Tee.oid()) {
        if !check_cert_ext_byte(cert_tee, report.reported_tcb.tee)? {
            return Err(Error::VerificationFailure(
                "Report TCB TEE and Certificate TEE mismatch encountered.".to_owned(),
            ));
        }
        debug!("Reported TCB TEE from certificate matches the attestation report.");
    }

    if let Some(cert_snp) = extensions.get(&SnpOid::Snp.oid()) {
        if !check_cert_ext_byte(cert_snp, report.reported_tcb.snp)? {
            return Err(Error::VerificationFailure(
                "Report TCB SNP and Certificate SNP mismatch encountered.".to_owned(),
            ));
        }
        debug!("Reported TCB SNP from certificate matches the attestation report.");
    }

    // TODO: for some reason (unknown...), it's not equal on AWS...
    // if let Some(cert_ucode) = extensions.get(&SnpOid::Ucode.oid()) {
    //     if !check_cert_ext_byte(cert_ucode, report.reported_tcb.microcode)? {
    //         return Err(Error::VerificationFailure(
    //             "Report TCB Microcode and Certificate Microcode mismatch
    //     encountered."
    //                 .to_owned(),
    //         ));
    //     }
    //     debug!(
    //         "Reported TCB Microcode from certificate matches the attestation
    //     report."
    //     );
    // }

    if let Some(cert_hwid) = extensions.get(&SnpOid::HwId.oid()) {
        if !check_cert_ext_bytes(cert_hwid, &report.chip_id) {
            return Err(Error::VerificationFailure(
                "Report Chip ID and Certificate Chip ID mismatch
        encountered."
                    .to_owned(),
            ));
        }
        debug!("Chip ID from certificate matches the attestation report.");
    }

    Ok(())
}

/// Request the AMD cert chain which signed the VLEK certificate
async fn request_amd_vlek_cert_chain(sev_prod_name: &str) -> Result<ca::Chain, Error> {
    let url = format!("{KDS_CERT_SITE}{KDS_VLEK}/{sev_prod_name}/{KDS_CERT_CHAIN}");
    request_amd_cert_chain(&url).await
}

/// Request the AMD cert chain which signed the VCEK certificate
async fn request_amd_vcek_cert_chain(sev_prod_name: &str) -> Result<ca::Chain, Error> {
    let url = format!("{KDS_CERT_SITE}{KDS_VCEK}/{sev_prod_name}/{KDS_CERT_CHAIN}");
    request_amd_cert_chain(&url).await
}

/// Requests the certificate-chain (AMD ASK + AMD ARK)
/// These may be used to verify the downloaded VCEK is authentic.
async fn request_amd_cert_chain(url: &str) -> Result<ca::Chain, Error> {
    // Should make -> https://kdsintf.amd.com/vcek/v1/{SEV_PROD_NAME}/cert_chain
    debug!("Requesting AMD certificate-chain from: {url}");
    let rsp = get(url).await?;
    let status = rsp.status();
    let body = rsp.bytes().await?;

    if !status.is_success() {
        return Err(Error::ResponseAPIError(format!(
            "Request to  {url} returns a {}: {}",
            status,
            String::from_utf8_lossy(&body),
        )));
    }

    let body = body.to_vec();
    let chain = X509::stack_from_pem(&body)?;

    // Create a ca chain with ark and ask
    Ok(ca::Chain::from_pem(
        &chain[1].to_pem()?,
        &chain[0].to_pem()?,
    )?)
}

/// Requests the VCEK for the specified chip and TCP
pub async fn request_vcek(
    sev_prod_name: &str,
    chip_id: [u8; 64],
    reported_tcb: TcbVersion,
) -> Result<Certificate, Error> {
    let hw_id = hex::encode(chip_id);
    let url = format!(
        "{KDS_CERT_SITE}{KDS_VCEK}/{sev_prod_name}/{hw_id}?blSPL={:02}&teeSPL={:02}&snpSPL={:02}&ucodeSPL={:02}",
        reported_tcb.bootloader, reported_tcb.tee, reported_tcb.snp, reported_tcb.microcode
    );
    debug!("Requesting VCEK from: {url}\n");

    let rsp = get(&url).await?;
    let status = rsp.status();
    let body = rsp.bytes().await?;

    if !status.is_success() {
        return Err(Error::ResponseAPIError(format!(
            "Request to  {url} returns a {}: {}",
            status,
            String::from_utf8_lossy(&body),
        )));
    }

    let body = body.to_vec();
    Ok(Certificate::from_der(&body)?)
}

/// Requests the revocation list
pub async fn request_crl(sev_prod_name: &str) -> Result<X509Crl, Error> {
    let url = format!("{KDS_CERT_SITE}{KDS_VCEK}/{sev_prod_name}/{KDS_CRL}");
    debug!("Requesting CRL from: {url}\n");

    let rsp = get(&url).await?;
    let status = rsp.status();
    let body = rsp.bytes().await?;

    if !status.is_success() {
        return Err(Error::ResponseAPIError(format!(
            "Request to  {url} returns a {}: {}",
            status,
            String::from_utf8_lossy(&body),
        )));
    }

    let body = body.to_vec();
    Ok(X509Crl::from_der(&body)?)
}
